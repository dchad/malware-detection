# generate-train-labels.py
#
# Generate training labels from ClamAV and Windows Defender reports. For each malware type
# a unique scalar value is generated as a training label, the malware family type is then
# determined by removing version numbers/names from the malware definition and generating
# a unique scalar training value for each malware family.
#
# Inputs : sorted-av-report.csv (generated by combine-av-reports.py)
#          row format = [file_name, clamav_malware_type, windefender_malware_type]
#
# Outputs: sorted-train-labels.csv
#          row format = [file_name, malware_type, malware_label, family_type, family_label] 
#
#          Also creates the following malware label and count files:
#
#          sorted-av-report-labels.csv (temp file)
#          malware-family-counts.csv   (temp file)
#          malware-family-labels.csv   (temp file)
#          malware-class-counts.csv    (temp file)
#          malware-class-labels.csv    (temp file)
#
#          malware-family-wd.csv 
#          row format = [malware_family_name, label, count]
#
#          malware-class-wd.csv
#          row format = [malware_class_name, label, count]
#
# Author: Derek Chadwick
# Date  : 30/07/2016


import os
from csv import writer
import numpy as np
import pandas as pd
import io # this is required as a compatability layer between 2.x and 3.x because 2.x cannot read utf-16 text files.
import re


def save_family_counts(family_counter_map):
    # Output the malware family counts.
    fop = open('data/malware-family-counts-wd.csv', 'w')
    csv_wouter = writer(fop)
    cols = ['malware_type','count'] # write out the column names.
    csv_wouter.writerow(cols)
    outlines = []
    sorted_keys = family_counter_map.keys()
    sorted_keys.sort()
    counter = 0
    for key in sorted_keys:
        outlines.append([key, family_counter_map[key]])
        counter += 1
        if (counter % 100) == 0: # write out some lines
            csv_wouter.writerows(outlines)
            outlines = []
            print("Processed family {:s} -> {:d}.".format(key, family_counter_map[key]))

    # Finish off.
    if (len(outlines) > 0):
        csv_wouter.writerows(outlines)
        outlines = []

    print("Completed processing {:d} families.".format(len(sorted_keys)))    
    fop.close()

    return


def save_sample_counts(sample_counter_map):
    # Output the malware sample classification counts.
    fop = open('data/malware-class-counts-wd.csv', 'w')
    csv_wouter = writer(fop)
    cols = ['malware_type','count'] # write out the column names.
    csv_wouter.writerow(cols)
    outlines = []
    sorted_keys = sample_counter_map.keys()
    sorted_keys.sort()
    counter = 0
    for key in sorted_keys:
        outlines.append([key, sample_counter_map[key]])
        counter += 1
        if (counter % 100) == 0: # write out some lines
            csv_wouter.writerows(outlines)
            outlines = []
            print("Processed sample {:s} -> {:d}.".format(key, sample_counter_map[key]))

    # Finish off.
    if (len(outlines) > 0):
        csv_wouter.writerows(outlines)
        outlines = []

    print("Completed processing {:d} samples.".format(len(sorted_keys)))    
    fop.close()

    return


def save_family_labels(family_label_map):
    # Output the malware family scalar classifications.
    fop = open('data/av-malware-family-labels-wd.csv', 'w')
    csv_wouter = writer(fop)
    cols = ['malware_type','class'] # write out the column names.
    csv_wouter.writerow(cols)
    outlines = []
    counter = 0
    sorted_keys = family_label_map.keys()
    sorted_keys.sort()
    for key in sorted_keys:
        outlines.append([key, family_label_map[key]])
        counter += 1
        if (counter % 100) == 0: # write out some lines
            csv_wouter.writerows(outlines)
            outlines = []
            print("Processed family label {:s} -> {:d}.".format(key, family_label_map[key]))

    # Finish off.
    if (len(outlines) > 0):
        csv_wouter.writerows(outlines)
        outlines = []

    print("Completed processing {:d} family labels.".format(len(sorted_keys)))  
    
    fop.close()

    return


def save_sample_labels(scalar_label_map):
    # Output the malware sample scalar classifications.
    fop = open('data/av-malware-class-labels-wd.csv', 'w')
    csv_wouter = writer(fop)
    cols = ['malware_type','class'] # write out the column names.
    csv_wouter.writerow(cols)
    outlines = []
    counter = 0
    sorted_keys = scalar_label_map.keys()
    sorted_keys.sort()
    for key in sorted_keys:
        outlines.append([key, scalar_label_map[key]])
        counter += 1
        if (counter % 100) == 0: # write out some lines
            csv_wouter.writerows(outlines)
            outlines = []
            print("Processed label {:s} -> {:d}.".format(key, scalar_label_map[key]))

    # Finish off.
    if (len(outlines) > 0):
        csv_wouter.writerows(outlines)
        outlines = []

    print("Completed processing {:d} labels.".format(counter))
    
    fop.close()

    return


def get_sample_labels(mal_df, label_df):
    # Read in the malware labels file and update with new samples.
    scalar_labels_dict = {}
    type_y = np.array(mal_df['malware_type_y'])
    counter = label_df['class'].max() # Get the current maximum label value to start.
    
    for idx in range(label_df.shape[0]): # First fill the dict with the existing malware labels
        scalar_labels_dict[label_df.iloc[idx,0]] = label_df.iloc[idx,1]
        

    return counter, scalar_labels_dict


def get_family_labels(mal_df, label_df):
    # Read in the malware family labels and update with new families.
    family_labels_dict = {}
    counter = label_df['class'].max() # Get the current maximum label value to start.
    
    for idx in range(label_df.shape[0]): # First fill the dict with the existing malware labels
        family_labels_dict[label_df.iloc[idx,0]] = label_df.iloc[idx,1]
        
    
    return counter, family_labels_dict



def generate_sample_labels(av_report_file, out_report_file, label_file):
    mals = pd.read_csv(av_report_file)
    labels = pd.read_csv(label_file)
    # Now generate unique scalar label map, we will use WinDefender as the default classification, if WinDefender is OK
    # and ClamAV is not OK, then use the ClamAV classification, if both are OK then default to 0 label value for now.
    type_x = np.array(mals['malware_type_x'])
    type_y = np.array(mals['malware_type_y'])
    scalar_labels = [0] * mals.shape[0]
    counter, scalar_label_map = get_sample_labels(mals, labels) # Get the malware label dict.
    
    for idx, y_val in enumerate(type_y):
        if y_val != 'OK':
            mals.iloc[idx,1] = y_val # copy the defender classification to ClamAV classification

        # Now update the label map with a new scalar label values
        if mals.iloc[idx,1] not in scalar_label_map.keys():
            counter += 1
            scalar_label_map[mals.iloc[idx,1]] = counter
            
        # now get the scalar label for this malware sample
        scalar_labels[idx] = scalar_label_map[mals.iloc[idx,1]]

        if (idx % 1000) == 0: # report progress
            print("Processed label: {:d} {:s} -> {:d}.".format(idx, mals.iloc[idx,1], scalar_labels[idx]))
    
    mals['sample_label'] = scalar_labels

    mals.to_csv(out_report_file, index=False)

    save_sample_labels(scalar_label_map)
    
    return


def generate_family_labels(in_report_file, out_report_file, label_file):
    # Now generate unique scalar label map for malware families.
    mals = pd.read_csv(in_report_file)
    labels = pd.read_csv(label_file)
    type_x = np.array(mals['malware_type_x'])
    family_scalar_labels = [0] * mals.shape[0]
    family_labels = [' '] * mals.shape[0]
    sample_counter_map = {}
    family_counter_map = {}
    malware_family = 'unknown'
    
    pwd1 = re.compile('(\w+):(\w+)/(\w+)[!.-/]+(\w+)') # Windows Defender malware definition patterns.
    pwd2 = re.compile('(\w+):(\w+)/(\w+)')
    pcav = re.compile('(\w+)\.(\w+)\.(\w+)[!./-](\w+)') # ClamAV malware definition pattern.
    
    counter, family_label_map = get_family_labels(mals, labels) # Get the malware family scalar labels.

    for idx, x_val in enumerate(type_x):
        # first count the sample type
        if x_val in sample_counter_map.keys():
            sample_counter_map[x_val] += 1
        else:
            sample_counter_map[x_val] = 1

        if x_val != 'OK':
            # if it is a defender classification then convert to ClamAV definition style.
            m = pwd1.match(x_val)
            if m != None:
                malware_family = m.group(2) + '.' + m.group(1) + '.' + m.group(3) # rearrange the components to
            else:                                                                 # (platform).(class).(type)
                m = pwd2.match(x_val)
                if m != None:
                    malware_family = m.group(2) + '.' + m.group(1) + '.' + m.group(3) 
                else:
                    # then check if it is a ClamAV definition.
                    m = pcav.match(x_val)
                    if m != None:        # just truncate the end bit off.
                        malware_family = m.group(1) + '.' + m.group(2) + '.' + m.group(3)
                    else:
                        malware_family = x_val  # catch the corner cases and default to original name/definition.

        else:
            malware_family = 'unknown' # leave the scalar label == 0, the malware sample has not been classified.


        # Update the malware family label map with the new family and scalar label.
        if malware_family not in family_label_map.keys():
            counter += 1
            family_label_map[malware_family] = counter

        # Count the malware family occurrences.
        if malware_family in family_counter_map.keys():
            family_counter_map[malware_family] += 1
        else:
            family_counter_map[malware_family] = 1

        # now get the scalar label for this malware sample
        family_scalar_labels[idx] = family_label_map[malware_family]
        family_labels[idx] = malware_family

        if (idx % 1000) == 0: # report progress
            print("Processed family label {:d} {:s} -> {:d}.".format(idx, malware_family, family_label_map[malware_family]))

    # Finish off by adding malware family label to training label set.
    mals['family_name'] = family_labels
    mals['family_label'] = family_scalar_labels
    
    # mals.drop(['malware_type_y', '_merge'], axis=1, inplace=True)
    mals.drop('malware_type_y', axis=1, inplace=True)

    mals.to_csv(out_report_file, index=False)

    save_family_labels(family_label_map)
    save_sample_counts(sample_counter_map)
    save_family_counts(family_counter_map)

    return


# Load in the train labels for each sample set run then compare the 
# training label value for each malware family and class to ensure
# each one has a unique scalar training label and the same malware
# types and families have the same label.
# [filename,malware_type_x,malware_type_y,sample_label,family_name,family_label]

def validate_label_generation():
    mals1_df = pd.read_csv('data/sorted-train-labels-vs251-252.csv')
    mals2_df = pd.read_csv('data/sorted-train-labels-vs263-264-apt.csv')

    counter = 0
    m1_x = np.array(mals1_df['malware_type_x'])
    m1_f = np.array(mals1_df['family_name'])
    m1_sl = np.array(mals1_df['sample_label'])
    m1_fl = np.array(mals1_df['family_label'])
    m2_x = np.array(mals2_df['malware_type_x'])
    m21_f = np.array(mals2_df['family_name'])
    m2_sl = np.array(mals2_df['sample_label'])
    m2_fl = np.array(mals2_df['family_label'])
    
    for idx1, mname1 in enumerate(m1_x):
        for idx2, mname2 in enumerate(m2_x):
            if mname1 == mname2:
                if m1_sl[idx1] != m2_sl[idx2]:
                    print("Sample label incongruence: {:d} {:d}".format(m1_sl[idx1], m2_sl[idx2]))
                    counter += 1
                    
                if (m1_fl[idx1] != m2_fl[idx2]):
                    print("Family label incongruence: {:d} {:d}".format(m1_fl[idx1], m2_fl[idx2]))
                    counter += 1            
        
        if (idx1 % 1000) == 0:
            print("Processed {:d} malware names.".format(idx1))


    print("Total Incongruence Errors: {:d}".format(counter))
    
    return


# Start of script.
if __name__ == "__main__":

    #TODO: parse command line options for input/output file names.

    av_report_file = 'data/sorted-av-report-vs251-252.csv'
    report_labels_file = 'data/sorted-av-report-labels-vs251-252.csv'
    train_labels_file = 'data/sorted-train-labels-vs251-252.csv'
    class_labels_file = 'data/av-malware-class-labels.csv'
    family_labels_file = 'data/av-malware-family-labels.csv'

    generate_sample_labels(av_report_file, report_labels_file, class_labels_file)
    generate_family_labels(report_labels_file, train_labels_file, family_labels_file)

    av_report_file = 'data/sorted-av-report-vs263-264-apt.csv'
    report_labels_file = 'data/sorted-av-report-labels-vs263-264-apt.csv'
    train_labels_file = 'data/sorted-train-labels-vs263-264-apt.csv'
    class_labels_file = 'data/av-malware-class-labels.csv'
    family_labels_file = 'data/av-malware-family-labels.csv'

    generate_sample_labels(av_report_file, report_labels_file, class_labels_file)
    generate_family_labels(report_labels_file, train_labels_file, family_labels_file)


    # Join the malware family sample scalar classifications and counts.
    #cldf = pd.read_csv('data/malware-family-labels-wd.csv')
    #ccdf = pd.read_csv('data/malware-family-counts-wd.csv')
    #cjdf = pd.merge(cldf,ccdf,on='malware_type')
    #cjdf.to_csv('data/malware-family-wd.csv', index=False)

    # Join the malware sample scalar classifications and counts.
    #cldf = pd.read_csv('data/malware-class-labels-wd.csv')
    #ccdf = pd.read_csv('data/malware-class-counts-wd.csv')
    #cjdf = pd.merge(cldf,ccdf,on='malware_type')
    #cjdf.to_csv('data/malware-class-wd.csv', index=False)

    #validate_label_generation()

# End of Script
















